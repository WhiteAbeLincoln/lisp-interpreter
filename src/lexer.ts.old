/* Contains the old lexer implementation
  I never ended up putting it in source control, and after
  I rewrote, I didn't want to just delete it, so it goes here
*/
import { tuple } from './util'

export type TokenBase = {
  origvalue: string
  line: number
  column: number
}
export type OpenParen = { kind: 'paren'; value: 'open' } & TokenBase
export type CloseParen = { kind: 'paren'; value: 'close' } & TokenBase
export type ParenToken = OpenParen | CloseParen
export type SymToken = { kind: 'symbol'; value: string } & TokenBase
export type NumToken = { kind: 'number'; value: number } & TokenBase
export type StringToken = { kind: 'string'; value: string } & TokenBase
export type Token = SymToken | NumToken | ParenToken | StringToken

export const printToken = (tok: Token) => {
  switch (tok.kind) {
    case 'number':
      return `Number(${tok.value})`
    case 'paren':
      return tok.origvalue
    case 'symbol':
      return `Symbol(${tok.value})`
  }
}

export const usePositionState = (
  obj: { line: number; col: number } = { line: 1, col: 0 },
) =>
  tuple(obj as Readonly<typeof obj>, (v: string) => {
    if (v === '\n') {
      obj.line++
      obj.col = 0
    } else {
      obj.col += v.length
    }
  })

export const whitespace = /\s/
export const number = /[0-9]/
export const syntaxError = (
  char: string,
  { line, col }: { line: number; col: number },
) => new SyntaxError(`Unexpected token \`${char}\` at ${line}:${col}`)

type AutomatonState = {
  pos: { line: number; col: number }
  accum: { line: number; col: number; value: '' }
  output: Token[]
  index: number
  input: string
  finished: boolean
}

const ERR = -Infinity
const accumulate = (a: AutomatonState, str?: string) => {
  const current = str || a.input[a.index - 1]
  if (a.accum.line === 0) {
    a.accum.line = a.pos.line
  }
  if (a.accum.col === 0) {
    a.accum.col = a.pos.col
  }
  a.accum.value += current
}

const checkAccum = (a: AutomatonState) => {
  const current = a.input[a.index - 1]
  if (current === '.' && a.accum.value.includes('.')) {
    throw syntaxError(current, a.pos)
  }
  accumulate(a)
}

const setFinished = (a: AutomatonState) => {
  a.finished = true
}

const retract = (a: AutomatonState) => {
  const current = a.input.charAt(--a.index)
  if (current === '\n') {
    a.pos.line--
    const lastNewline = a.input.lastIndexOf('\n', a.index)
    a.pos.col = a.index - lastNewline
  } else {
    a.pos.col--
  }
}
const ret = (a: AutomatonState, token: Token) => {
  a.output.push(token)
  a.accum = { line: 0, col: 0, value: '' }
}

const retractingStates: {
  [x: number]: ((a: AutomatonState) => void) | undefined
} = {
  2: retract,
  3: retract,
  5: retract,
}

const acceptingStates: {
  [x: number]: ((a: AutomatonState) => void) | undefined
} = {
  2: a =>
    ret(a, {
      kind: 'number',
      value: parseFloat(a.accum.value),
      origvalue: a.accum.value,
      line: a.accum.line,
      column: a.accum.col,
    }),
  3: a => {
    const char = a.input[a.index - 1]
    ret(a, {
      kind: 'paren',
      value: char === '(' ? 'open' : 'close',
      origvalue: char,
      line: a.pos.line,
      column: a.pos.col,
    } as ParenToken)
  },
  5: a =>
    ret(a, {
      kind: 'symbol',
      origvalue: a.accum.value,
      value: a.accum.value,
      line: a.accum.line,
      column: a.accum.col,
    }),
}
const transitionTable: Array<
  Array<[number, ((state: AutomatonState) => void)?]>
> =
  // prettier-ignore
  [
/*               ' ' | '\t', '\n', number,              paren, ;,   other,           .                Îµ                 -
/* ENTRY   0 */[ [0],        [0],  [1, accumulate],     [3],   [6], [4, accumulate], [8, accumulate], [0, setFinished], [7, accumulate]],
/* NUM     1 */[ [2],        [2],  [1, accumulate],     [2],   [2], [ERR],           [1, checkAccum], [2],              [ERR]          ],
/* *R(NUM) 2 */[ [0],        [0],  [0],                 [0],   [0], [0],             [0],             [0],              [0]            ],
/* *R(PRN) 3 */[ [0],        [0],  [0],                 [0],   [0], [0],             [0],             [0, setFinished], [0]            ],
/* SYM     4 */[ [5],        [5],  [4, accumulate],     [5],   [5], [4, accumulate], [4, accumulate], [5],              [4, accumulate]],
/* *R(SYM) 5 */[ [0],        [0],  [0],                 [0],   [0], [0],             [0],             [0],              [0]            ],
/* CMMT    6 */[ [6],        [0],  [6],                 [6],   [6], [6],             [6],             [0],              [6]            ],
/* DASH    7 */[ [5],        [5],  [1, accumulate],     [5],   [5], [4, accumulate], [1, accumulate], [5],              [4, accumulate]],
/* PERIOD  8 */[ [5],        [5],  [1, accumulate],     [5],   [5], [4, accumulate], [4, accumulate], [5],              [4, accumulate]],
]

function step(
  state: number | [number, (state: AutomatonState) => {}],
  c: string,
  autoState: AutomatonState,
) {
  /** the current token ' ' '\t' number, paren, ;, ., other */
  // prettier-ignore
  const tokenIdx
    // prettier-ignore
    = c === ' ' || c === '\t' ? 0
    : c === '\n'              ? 1
    : number.test(c)          ? 2
    : c === '(' || c === ')'  ? 3
    : c === ';'               ? 4
    : c === '.'               ? 6
    : c === ''                ? 7
    : c === '-'               ? 8
    :                           5

  /** the current state (ENTRY, NUM, R(NUM) R(PRN) SYM R(SYM) CMMT) */
  const stateIdx = typeof state === 'number' ? state : state[0]
  const retractingFun = retractingStates[stateIdx]
  if (retractingFun) {
    retractingFun(autoState)
  }
  /** the next state */
  const [branchIdx, branchFn] = transitionTable[stateIdx][tokenIdx]
  if (branchFn) {
    branchFn(autoState)
  }
  const acceptionFun = acceptingStates[branchIdx]
  if (acceptionFun) {
    acceptionFun(autoState)
  }
  return branchIdx
}

const getNextChar = (a: AutomatonState) => {
  const char = a.input.charAt(a.index)
  if (a.index < a.input.length) {
    a.index += 1
  }
  return char
}

// this table driven lexer has issues with dropping parentheses preceded by numbers or symbols
export function lex(input: string) {
  let stateIdx: number = 0
  const [pos, setPosFrom] = usePositionState()
  const automatonState: AutomatonState = {
    pos,
    accum: { line: 0, col: 0, value: '' },
    output: [],
    index: 0,
    input,
    finished: false,
  }
  let c: string | undefined = ''
  while (!automatonState.finished) {
    c = getNextChar(automatonState)
    setPosFrom(c)
    stateIdx = step(stateIdx, c, automatonState)
    if (stateIdx === ERR) throw syntaxError(c, automatonState.pos)
  }
  return automatonState.output
}

// vim: ft=ts
